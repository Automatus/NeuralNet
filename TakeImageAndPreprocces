import cv2
import numpy as np
import os
import random

print("NeuralNet by Automatus: Teaching Neural Network...")

npzfile = np.load(os.path.join(os.getcwd(), "Nets", "NNvision.npz"))  # open file

# Reading file
b = npzfile["arr_0"][0]
step = npzfile["arr_0"][1]
minrand = npzfile["arr_0"][2]
maxrand = npzfile["arr_0"][3]
number_of_inputs = int(npzfile["arr_0"][4])
number_of_hidden_layers = int(npzfile["arr_0"][5])
number_of_neurons_in_layer = int(npzfile["arr_0"][6])
number_of_outputs = int(npzfile["arr_0"][7])
wi = npzfile["arr_1"]
w = npzfile["arr_2"]
wo = npzfile["arr_3"]

inputs = np.zeros((1, number_of_inputs))
neurons = np.zeros((number_of_hidden_layers, number_of_neurons_in_layer))
outputs = np.zeros((1, number_of_outputs))
youtputs = np.zeros((1, number_of_outputs))  # desired outputs
spll = np.zeros((1, number_of_neurons_in_layer))  # SPiking neurons in Last investigated Layer that have a connection to the output that is being updated

variables = np.array([b, step, minrand, maxrand, number_of_inputs, number_of_hidden_layers, number_of_neurons_in_layer, number_of_outputs])

currentimage = cv2.VideoCapture(0)
cv2.namedWindow("preview")

for running in range(30):
    if running == 0:
        input("Please make the object APPEAR in the next photos")
        youtputs[0,0] = 1
    if running == 15:
        input("Please make NO(!) object appear in the next photos")
        youtputs[0,0] = 0

    currentframe = currentimage.read()
    print(currentframe)
    cv2.imshow("preview", currentframe)
    currentframe = cv2.resize(currentframe, None, fx=0.1, fy=0.1, interpolation=cv2.INTER_LINEAR)
    red = currentframe[:, :, 0]  # + currentframe[:, :, 1] + currentframe[:, :, 2]
    c = np.reshape(red, (1, 3072))
    print(c)
    inputs = c

    i = 0  # index for output
    for item in youtputs[0, :]:  # iterating through outputs
        if 1 not in neurons[-1, :] and item:  # if no active neurons in last layer and desired output is 1
            j = -2  # index for layer
            stop = False
            while j >= -number_of_hidden_layers-1:  # iterating through layers
                if not stop:
                    if j == -number_of_hidden_layers-1 and 1 in inputs:  # if all neurons are negative, but positive input:
                        t = 0  # index for input
                        for bla in inputs[0, :]:  # iterating through inputs
                            if bla:  # if input is active
                                r = 0
                                for thing in wi[t, :]:
                                    wi[t, r] = wi[t, r] + step*random.randint(minrand, maxrand)/1000  # strenghten weights/connections to neurons
                                    r += 1
                            t += 1
                    elif 1 in neurons[j, :]:  # if active neuron present in layer s
                        stop = True
                        t = 0  # index for neuron
                        for neuron in neurons[j, :]:  # iterating through neurons
                            if neuron:  # if neuron is active
                                r = 0
                                for thingy in w[j+1, :, t]:
                                    w[j+1, r, t] = w[j+1, r, t] + step/number_of_neurons_in_layer*random.randint(minrand, maxrand)/1000  # strenghten weights/connections in proportion to number of neurons
                                    r += 1
                            t += 1
                j += -1
        else:  # if active neurons in last layer are present
            f_error = youtputs[0, i] - outputs[0, i]  # calculate error
            j = -1  # index for layer of neurons
            k = 0  # index for neuron in layer j
            for neuron in neurons[j, :]:
                if neuron:  # if neuron is firing
                    wo[k, i] = wo[k, i] + f_error * step/number_of_neurons_in_layer*random.randint(minrand, maxrand)/1000  # change weight strenght in proportion to error and number of neurons
                    spll[0, k] = True  # remember spiking neuron for next iterations
                k += 1
            j = j - 1
            while j > -number_of_hidden_layers:  # while iterating through neural layers
                k = 0
                for neuron in neurons[j, :]:  # iterating through neurons in layer j
                    if neuron:  # if neuron fired
                        z = 0
                        for thing in spll[0, :]:  # iterating through remembered spiking neurons
                            if spll[0, z]:  # if neuron spiked
                                w[j+1, z, k] = w[j+1, z, k] + f_error * step/number_of_neurons_in_layer*random.randint(minrand, maxrand)/1000  # change weight strenght in proportion to error and number of neurons
                            z += 1
                    k += 1
                j += -1
            x = 0
            for innn in inputs[0, :]:  # iterating through inputs
                if innn:  # if input is 1
                    q = 0
                    for it in spll[0, :]:  # iterating through remembered spiking neurons
                        if spll[0, q]:  # if neuron spiked
                            wi[x, q] = wi[x, q] + f_error * step*random.randint(minrand, maxrand)/1000  # change weight strenght in proportion to error
                        q += 1
                x += 1
        i += 1

    print("NeuralNet v3 by Automatus: Weights updated\n")
    np.savez((os.path.join(os.getcwd(), "Nets", "NNvision.npz")), variables, wi, w, wo)
    print("Net Saved")
    cv2.destroyAllWindows()
